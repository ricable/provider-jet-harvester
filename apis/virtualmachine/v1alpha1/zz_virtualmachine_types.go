/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CloudinitObservation struct {
}

type CloudinitParameters struct {

	// +kubebuilder:validation:Optional
	NetworkData *string `json:"networkData,omitempty" tf:"network_data,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkDataBase64 *string `json:"networkDataBase64,omitempty" tf:"network_data_base64,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkDataSecretName *string `json:"networkDataSecretName,omitempty" tf:"network_data_secret_name,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// +kubebuilder:validation:Optional
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// +kubebuilder:validation:Optional
	UserDataBase64 *string `json:"userDataBase64,omitempty" tf:"user_data_base64,omitempty"`

	// +kubebuilder:validation:Optional
	UserDataSecretName *string `json:"userDataSecretName,omitempty" tf:"user_data_secret_name,omitempty"`
}

type DiskObservation struct {
}

type DiskParameters struct {

	// +kubebuilder:validation:Optional
	AccessMode *string `json:"accessMode,omitempty" tf:"access_mode,omitempty"`

	// +kubebuilder:validation:Optional
	AutoDelete *bool `json:"autoDelete,omitempty" tf:"auto_delete,omitempty"`

	// +kubebuilder:validation:Optional
	BootOrder *float64 `json:"bootOrder,omitempty" tf:"boot_order,omitempty"`

	// +kubebuilder:validation:Optional
	Bus *string `json:"bus,omitempty" tf:"bus,omitempty"`

	// +kubebuilder:validation:Optional
	ContainerImageName *string `json:"containerImageName,omitempty" tf:"container_image_name,omitempty"`

	// +kubebuilder:validation:Optional
	ExistingVolumeName *string `json:"existingVolumeName,omitempty" tf:"existing_volume_name,omitempty"`

	// +kubebuilder:validation:Optional
	HotPlug *bool `json:"hotPlug,omitempty" tf:"hot_plug,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Size *string `json:"size,omitempty" tf:"size,omitempty"`

	// +kubebuilder:validation:Optional
	StorageClassName *string `json:"storageClassName,omitempty" tf:"storage_class_name,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeMode *string `json:"volumeMode,omitempty" tf:"volume_mode,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeName *string `json:"volumeName,omitempty" tf:"volume_name,omitempty"`
}

type NetworkInterfaceObservation struct {
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	InterfaceName *string `json:"interfaceName,omitempty" tf:"interface_name,omitempty"`
}

type NetworkInterfaceParameters struct {

	// +kubebuilder:validation:Optional
	MacAddress *string `json:"macAddress,omitempty" tf:"mac_address,omitempty"`

	// +kubebuilder:validation:Optional
	Model *string `json:"model,omitempty" tf:"model,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkName *string `json:"networkName,omitempty" tf:"network_name,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type VirtualmachineObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	NodeName *string `json:"nodeName,omitempty" tf:"node_name,omitempty"`

	State *string `json:"state,omitempty" tf:"state,omitempty"`
}

type VirtualmachineParameters struct {

	// +kubebuilder:validation:Optional
	CPU *float64 `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// +kubebuilder:validation:Optional
	Cloudinit []CloudinitParameters `json:"cloudinit,omitempty" tf:"cloudinit,omitempty"`

	// Any text you want that better describes this resource
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Required
	Disk []DiskParameters `json:"disk" tf:"disk,omitempty"`

	// +kubebuilder:validation:Optional
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// +kubebuilder:validation:Optional
	MachineType *string `json:"machineType,omitempty" tf:"machine_type,omitempty"`

	// +kubebuilder:validation:Optional
	Memory *string `json:"memory,omitempty" tf:"memory,omitempty"`

	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Required
	NetworkInterface []NetworkInterfaceParameters `json:"networkInterface" tf:"network_interface,omitempty"`

	// more info: https://kubevirt.io/user-guide/virtual_machines/run_strategies/
	// +kubebuilder:validation:Optional
	RunStrategy *string `json:"runStrategy,omitempty" tf:"run_strategy,omitempty"`

	// +kubebuilder:validation:Optional
	SSHKeys []*string `json:"sshKeys,omitempty" tf:"ssh_keys,omitempty"`

	// +kubebuilder:validation:Optional
	Start *bool `json:"start,omitempty" tf:"start,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

// VirtualmachineSpec defines the desired state of Virtualmachine
type VirtualmachineSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     VirtualmachineParameters `json:"forProvider"`
}

// VirtualmachineStatus defines the observed state of Virtualmachine.
type VirtualmachineStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        VirtualmachineObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Virtualmachine is the Schema for the Virtualmachines API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,harvesterjet}
type Virtualmachine struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualmachineSpec   `json:"spec"`
	Status            VirtualmachineStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// VirtualmachineList contains a list of Virtualmachines
type VirtualmachineList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Virtualmachine `json:"items"`
}

// Repository type metadata.
var (
	Virtualmachine_Kind             = "Virtualmachine"
	Virtualmachine_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Virtualmachine_Kind}.String()
	Virtualmachine_KindAPIVersion   = Virtualmachine_Kind + "." + CRDGroupVersion.String()
	Virtualmachine_GroupVersionKind = CRDGroupVersion.WithKind(Virtualmachine_Kind)
)

func init() {
	SchemeBuilder.Register(&Virtualmachine{}, &VirtualmachineList{})
}
